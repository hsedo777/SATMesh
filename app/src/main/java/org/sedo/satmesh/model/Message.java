package org.sedo.satmesh.model;


import static androidx.room.ForeignKey.CASCADE;

import androidx.annotation.IntDef;
import androidx.annotation.NonNull;
import androidx.room.ColumnInfo;
import androidx.room.Entity;
import androidx.room.ForeignKey;
import androidx.room.Index;
import androidx.room.PrimaryKey;

import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.util.Objects;

/**
 * Represents a message sent or received in the application.
 * Messages can be of various types (text, image, etc.) and have different statuses
 * indicating their delivery and read state.
 */
@Entity(tableName = "message",
		foreignKeys = {
				@ForeignKey(entity = Node.class,
						parentColumns = "id", // Foreign key from Node's primary key (id)
						childColumns = "senderNodeId", // Column in Message for the sender's Node ID
						onDelete = CASCADE), // If a sender node is deleted, delete their messages
				@ForeignKey(entity = Node.class,
						parentColumns = "id", // Foreign key from Node's primary key (id)
						childColumns = "recipientNodeId", // Column in Message for the recipient's Node ID
						onDelete = CASCADE) // If a recipient node is deleted, delete associated messages
		},
		indices = {@Index(value = "payloadId", unique = true), @Index(value = "senderNodeId"), @Index("recipientNodeId")})
public class Message {

	//For messages statuses, we opt to use integer constants instead of enum constants
	/**
	 * Message status code when the message is pending (waiting to be sent/routed).
	 */
	public static final int MESSAGE_STATUS_PENDING = 1;
	/**
	 * Message status code when the message has been successfully delivered to the recipient.
	 */
	public static final int MESSAGE_STATUS_DELIVERED = 2;
	/**
	 * Message status code when the message sending fails (e.g., no route found, timeout).
	 */
	public static final int MESSAGE_STATUS_FAILED = 3;
	/**
	 * Message status code when the recipient has read the message.
	 */
	public static final int MESSAGE_STATUS_READ = 4;
	/**
	 * Message status code when the message is actively being routed through the mesh network
	 * but no delivery confirmation has been received yet.
	 */
	public static final int MESSAGE_STATUS_ROUTING = 5;
	/**
	 * Used to mark message when it was sent in context where there is no active secure
	 * session between the implied nodes.
	 */
	public static final int MESSAGE_STATUS_PENDING_KEY_EXCHANGE = 6;
	/**
	 * Message status code when the message has been successfully
	 * sent (when receiver is a neighbor) and is awaiting delivery confirmation.
	 */
	public static final int MESSAGE_STATUS_SENT = 7;

	//For message type, we opt to integer constants instead of enum constants
	/**
	 * Code for a text message.
	 */
	public static final int MESSAGE_TYPE_TEXT = 0;
	/**
	 * Code for an image message. (Note: Current implementation might not support this yet)
	 */
	public static final int MESSAGE_TYPE_IMAGE = 1;
	/**
	 * Code for an audio message/voice note. (Note: Current implementation might not support this yet)
	 */
	public static final int MESSAGE_TYPE_AUDIO = 2;
	/**
	 * Code for a file message. (Note: Current implementation might not support this yet)
	 */
	public static final int MESSAGE_TYPE_FILE = 3;

	@PrimaryKey(autoGenerate = true)
	private Long id;

	/**
	 * A unique identifier for the message's payload, typically generated by the sender.
	 * Used for tracking delivery and read receipts across the network.
	 */
	private Long payloadId;

	/**
	 * The content of the message. For text messages, this is the actual text.
	 * For other types (image, audio, file), this will be a local URI or path to the content.
	 */
	private String content;

	/**
	 * The timestamp when the message was sent, in milliseconds since the epoch.
	 */
	private long timestamp;

	/**
	 * The current status of the message (e.g., PENDING, DELIVERED, FAILED, READ, ROUTING).
	 * Uses MESSAGE_STATUS_* constants.
	 */
	private int status;

	/**
	 * The type of the message (e.g., TEXT, IMAGE, AUDIO, FILE).
	 * Uses MESSAGE_TYPE_* constants.
	 */
	private int type;

	/**
	 * The database ID of the sender Node.
	 * This acts as a foreign key to the 'node' table's 'id' column.
	 */
	@ColumnInfo(name = "senderNodeId")
	private Long senderNodeId;

	/**
	 * The database ID of the recipient Node.
	 * This acts as a foreign key to the 'node' table's 'id' column.
	 */
	@ColumnInfo(name = "recipientNodeId")
	private Long recipientNodeId;

	/**
	 * The last time the message has been transmitted but without
	 * transmission result even if success or failure. It is also
	 * used to retain the last time the message was sent but without
	 * any ack from the recipient.
	 */
	@ColumnInfo(name = "lastAttempt")
	private Long lastSendingAttempt;

	public Message() {
	}

	public Message(@NonNull Message message) {
		this.id = message.id;
		this.payloadId = message.payloadId;
		this.content = message.content;
		this.timestamp = message.timestamp;
		this.status = message.status;
		this.type = message.type;
		this.senderNodeId = message.senderNodeId;
		this.recipientNodeId = message.recipientNodeId;
		this.lastSendingAttempt = message.lastSendingAttempt;
	}

	public Long getId() {
		return id;
	}

	public void setId(Long id) {
		this.id = id;
	}

	public Long getPayloadId() {
		return payloadId;
	}

	public void setPayloadId(Long payloadId) {
		if ((payloadId != null && payloadId == 0L)
				|| (this.payloadId != null && this.payloadId != 0L) //Prevent payload ID modification
		) {
			return;
		}
		this.payloadId = payloadId;
	}

	public String getContent() {
		return content;
	}

	public void setContent(String content) {
		this.content = content;
	}

	public long getTimestamp() {
		return timestamp;
	}

	public void setTimestamp(long timestamp) {
		this.timestamp = timestamp;
	}

	public @MessageStatus int getStatus() {
		return status;
	}

	public void setStatus(@MessageStatus int status) {
		this.status = status;
	}

	public @MessageType int getType() {
		return type;
	}

	public void setType(@MessageType int type) {
		this.type = type;
	}

	public Long getSenderNodeId() {
		return senderNodeId;
	}

	public void setSenderNodeId(Long senderNodeId) {
		this.senderNodeId = senderNodeId;
	}

	public Long getRecipientNodeId() {
		return recipientNodeId;
	}

	public void setRecipientNodeId(Long recipientNodeId) {
		this.recipientNodeId = recipientNodeId;
	}

	public boolean isDelivered() {
		return status == MESSAGE_STATUS_DELIVERED;
	}

	public boolean isRead() {
		return status == MESSAGE_STATUS_READ;
	}

	public Long getLastSendingAttempt() {
		return lastSendingAttempt;
	}

	public void setLastSendingAttempt(Long lastSendingAttempt) {
		this.lastSendingAttempt = lastSendingAttempt;
	}

	/**
	 * Checks if the message is sent to the specified recipient.
	 *
	 * @param recipient The recipient Node.
	 * @return {@code true} if the message is sent to the specified recipient.
	 */
	public boolean isSentTo(Node recipient) {
		return recipient != null && Objects.equals(recipientNodeId, recipient.getId());
	}

	/**
	 * Checks if the message has received an ack from the message's recipient.
	 *
	 * @return {@code true} if the message has received an ack from the message's recipient.
	 */
	public boolean hadReceivedAck() {
		return status == MESSAGE_STATUS_DELIVERED || status == MESSAGE_STATUS_READ;
	}

	/**
	 * Checks if the message is currently in the transmission queue.
	 *
	 * @return {@code true} if the message is currently in the transmission queue.
	 */
	public boolean isOnTransmissionQueue() {
		return status == MESSAGE_STATUS_PENDING && lastSendingAttempt != null;
	}

	@Override
	public boolean equals(Object o) {
		if (this == o) return true;
		if (o == null || getClass() != o.getClass()) return false;
		Message message = (Message) o;
		return timestamp == message.timestamp && status == message.status && type == message.type && Objects.equals(payloadId, message.payloadId) && Objects.equals(content, message.content) && Objects.equals(senderNodeId, message.senderNodeId) && Objects.equals(recipientNodeId, message.recipientNodeId);
	}

	@Override
	public int hashCode() {
		return Objects.hash(payloadId, content, timestamp, status, type, senderNodeId, recipientNodeId);
	}

	/**
	 * Defines the set of allowed integer constants for a message's status.
	 * This annotation ensures that any variable, parameter, or return value
	 * representing a message status uses one of the predefined {@code MESSAGE_STATUS_*}
	 * constants from the {@link Message} class.
	 */
	@IntDef({MESSAGE_STATUS_DELIVERED, MESSAGE_STATUS_PENDING, MESSAGE_STATUS_ROUTING,
			MESSAGE_STATUS_READ, MESSAGE_STATUS_FAILED, MESSAGE_STATUS_PENDING_KEY_EXCHANGE,
			MESSAGE_STATUS_SENT})
	@Retention(RetentionPolicy.SOURCE)
	@interface MessageStatus {
	}

	/**
	 * Defines the set of allowed integer constants for a message's type.
	 * This annotation ensures that any variable, parameter, or return value
	 * representing a message type uses one of the predefined {@code MESSAGE_TYPE_*}
	 * constants from the {@link Message} class.
	 */
	@IntDef({MESSAGE_TYPE_TEXT, MESSAGE_TYPE_IMAGE, MESSAGE_TYPE_AUDIO, MESSAGE_TYPE_FILE})
	@Retention(RetentionPolicy.SOURCE)
	@interface MessageType {
	}
}
