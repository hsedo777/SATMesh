syntax = "proto3";

// Define the Java package and filename for the generated classes
option java_package = "org.sedo.satmesh.proto";
option java_multiple_files = true; // Generates a separate .java file for each message

// Existing message for PreKeyBundle
message SignalPreKeyBundle {
  int32 registration_id = 1;
  int32 device_id = 2;
  int32 pre_key_id = 3;
  bytes pre_key_public_key = 4;
  int32 signed_pre_key_id = 5;
  bytes signed_pre_key_public_key = 6;
  bytes signed_pre_key_signature = 7;
  bytes identity_key_public_key = 8;
}

// New message for Key Exchange (wrapping the serialized PreKeyBundle)
message PreKeyBundleExchange {
  bytes pre_key_bundle = 1;       // The serialized SignalPreKeyBundle
  //bool response_expected = 2;     // Specify if the sender is expecting response from receiver
}

// New message for personal information exchange
message PersonalInfo{
  string address_name = 1; // The SignalProtocolAddress.name of the sender
  string display_name = 2; // The display name of the node
  bool expect_result = 3; // Inform the recipient if you want he send you his personal info
}

// Text message
message TextMessage{
  string content = 1;
  int64 timestamp = 2;
  int64 payloadId = 3;
}

// New generic message type for all Nearby Signal communications
message NearbyMessage {
  bool exchange = 1; // Specify if it is keys exchange message or not

  oneof payload_content {// Only one of these fields will be set
    PreKeyBundleExchange key_exchange_message = 2; //  PreKeySignalMessage
    bytes body = 3; // An encrypted value of NearbyMessageBody using the receiver PK
  }
}

// New generic message body type for all Nearby Signal encrypted communications
message NearbyMessageBody {
  enum MessageType {
    UNKNOWN = 0;
    ROUTE_DISCOVERY_REQ = 1;
    ENCRYPTED_MESSAGE = 2;
    MESSAGE_DELIVERED_ACK = 3;
    MESSAGE_READ_ACK = 4;
    PERSONAL_INFO = 5;
    ROUTE_DISCOVERY_RESP = 6;
    TYPING_INDICATOR = 7;
    ROUTED_MESSAGE = 8;
    KNOWLEDGE = 9;
    CLAIM_READ_ACK = 10;
    ROUTE_DESTROY = 11;
    ACK_CONFIRMATION = 12;
  }
  MessageType message_type = 1;
  /*
  * Raw bytes of CiphertextMessage (SignalMessage) : in {PersonalInfo, TextMessage,
  * MessageAck, TypingIndicator, RoutedMessage}
  * 
  * If message_type is ROUTED_MESSAGE, this field will contain the raw bytes
  * of a serialized `RoutedMessage` (which is itself encrypted hop-by-hop).
  */
  bytes binary_data = 3;
}

//Message for types `MESSAGE_DELIVERED_ACK`, `MESSAGE_READ_ACK` and `CLAIM_READ_ACK`
message MessageAck {
  int64 payloadId = 1; // original message payload ID
}

// Message type for `TYPING_INDICATOR`
message TypingIndicator {
  bool is_typing = 1; // True if the node is writing, False else
  string typing_source = 2; // Address name of source
}

// Defines the RouteRequestMessage structure used for route discovery in the decentralized mesh network.
// This message is sent between nodes to initiate and propagate a route search.
message RouteRequestMessage {// Message type `ROUTE_DISCOVERY_REQ`
  // A unique identifier for this specific route request.
  string uuid = 1;

  // The global identifier (address name) of the target destination node.
  string destination_node_id = 2;

  // The maximum number of hops remaining for this request to propagate.
  int32 remaining_hops = 3;

  // The expiration Time To Live (TTL) for this request, expressed in time units milliseconds.
  int64 max_ttl = 4;

  // The Signal protocol's address name of the initiator of the route request
  string initiator_node_id = 5;
}

// Defines the RouteResponseMessage structure used to respond to route discovery requests.
// This message indicates the specific outcome of a route discovery attempt.
message RouteResponseMessage {// Message type `ROUTE_DISCOVERY_RESP`
  // The UUID of the original RouteRequestMessage that this response pertains to.
  string request_uuid = 1;

  // The precise status or type of outcome for the route discovery request.
  enum Status {
    UNKNOWN_STATUS = 0;             // Default or uninitialized status.
    NO_ROUTE_FOUND = 1;             // Indicates that no path to the destination could be found.
    TTL_EXPIRED = 2;                // The message's Time To Live (TTL) expired before reaching the destination.
    MAX_HOPS_REACHED = 3;           // The maximum number of intermediate hops was reached.
    ROUTE_FOUND = 4;                // A valid route to the destination has been successfully discovered.
    REQUEST_ALREADY_IN_PROGRESS = 5; // The request was already being processed by an intermediate node.
  }
  Status status = 2;

  /*
   * If the status indicates a successful route discovery (ROUTE_FOUND),
   * this field contains the total number of hops (intermediate nodes + destination)
   * from the original source to the destination node.
   * This value helps in evaluating the path length. It is irrelevant for failure statuses.
   */
  int32 hop_count = 3;
}

// The end-to-end encrypted payload that only the final destination can decrypt.
// This message encapsulates the original NearbyMessageBody and the original sender's ID.
message RoutedMessageBody {
  // The SignalProtocolAddress.name of the original sender node.
  // string original_sender_node_id = 1;

  // The actual NearbyMessageBody (e.g., ENCRYPTED_MESSAGE, TYPING_INDICATOR) that the original sender intended for the final destination.
  NearbyMessageBody internal_message_body = 2;
}


// For encapsulating a message that is being routed hop-by-hop.
// This message will be contained within the 'encrypted_data' of an OUTER NearbyMessageBody
// whose message_type is ROUTED_MESSAGE.
message RoutedMessage {
  // The SignalProtocolAddress.name of the ultimate destination node.
  string final_destination_node_id = 1;

  // The UUID of the RouteEntry used to forward this message.
  string route_uuid = 2;

  // The UUID of the RouteUsage entry associated with this specific use of the route.
  string route_usage_uuid = 3;

  // The serialized and end-to-end encrypted `RoutedMessageBody`.
  bytes encrypted_routed_message_body = 4;

  // The SignalProtocolAddress.name of the original sender node.
  string original_sender_node_id = 5;

  // The payload ID to use to track the packet. Caller must ensure the value is set once
  int64 payload_id = 6;

  // Specify if the routed message is to send by backtracking
  bool for_backtracking = 7;
}

// For wrapping data when dispatching route destroying
message RouteDestroyMessage {
  // The UUID of the route to destroy.
  string route_uuid = 1;
}

// Defines the structure of message to use to send confirmation ack when receiving a message ack
// through a route
message MessageAckConfirmation {
  int32 ack_type = 1;
  int64 payload_id = 2;
}

// Provide the pack of shared data by QR code
message QRIdentity {
  string source_uuid = 1;
  string destination_uuid = 2;
  bytes pre_key_bundle = 3;
}
