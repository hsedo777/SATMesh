package org.sedo.satmesh.utils;

import android.content.Context;
import android.util.Log;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Locale;

/**
 * Manages the logging of performance and behavior data for the SATMesh application
 * into a dedicated file. This allows for subsequent automated analysis.
 * It uses a structured format for each log entry to facilitate parsing.
 * <p>
 * This class ensures thread-safe operations for logging.
 *
 * @author hovozounkou
 */
public class DataLog {

	private static final String TAG = "DataLog";
	// Log File Configuration
	private static final String LOG_FILE_DIR_NAME = "satmesh_logs";
	private static final String LOG_FILE_BASE_NAME = "data_log_";
	private static final String LOG_FILE_EXTENSION = ".txt";

	private static FileWriter writer;
	private static Context appContext; // Application context for file operations
	private static String localNodeUuid; // UUID of the local node, included in logs for context

	private DataLog(){}

	/**
	 * Initializes the DataLog manager. This method must be called once at the application's startup.
	 * It sets up the logging directory and creates/opens the log file for appending.
	 * All logging methods will be non-operational until this initialization is successful.
	 *
	 * @param context  The application context.
	 * @param nodeUuid The unique UUID string of the local node. This UUID will be included
	 *                 in every log entry generated by this instance for identification.
	 */
	public static synchronized void init(Context context, String nodeUuid) {
		if (writer == null) { // Ensure initialization happens only once
			appContext = context.getApplicationContext();
			localNodeUuid = nodeUuid;
			try {
				/*
				 * Using getExternalFilesDir ensures application-specific storage,
				 * which does not require WRITE_EXTERNAL_STORAGE permission on modern Android versions.
				 * Files are stored in: Android/data/(my.package)/files/satmesh_logs
				 */
				File logDir = new File(appContext.getExternalFilesDir(null), LOG_FILE_DIR_NAME);
				if (!logDir.exists()) {
					// Create the directory if it does not exist
					if (!logDir.mkdirs()) {
						Log.w(TAG, "Unable to create the log directory: " + logDir.getAbsolutePath());
						return;
					}
				}

				// Append current date to the log file name for easier management and rotation
				String dateStr = new SimpleDateFormat("yyyyMMdd", Locale.US).format(new Date());
				File currentLogFile = new File(logDir, LOG_FILE_BASE_NAME + dateStr + LOG_FILE_EXTENSION);

				// Initialize FileWriter in append mode (true)
				writer = new FileWriter(currentLogFile, true);
				Log.i(TAG, "DataLog initialized. File path: " + currentLogFile.getAbsolutePath());
			} catch (IOException e) {
				Log.e(TAG, "Error initializing DataLog file: " + e.getMessage(), e);
				writer = null; // Set writer to null to indicate initialization failure
			}
		}
	}

	/**
	 * Logs an event related to node discovery or connection status.
	 * This method automatically adds a timestamp and the local node's UUID.
	 * <p>
	 * The log entry format is:
	 * [TIMESTAMP_MS] NODE_DISCOVERY [LOCAL_NODE_UUID] [EVENT_TYPE] [REMOTE_NODE_UUID] [REMOTE_NODE_ENDPOINT_ID] [REMOTE_NODE_NAME] [ADDITIONAL_INFO (optional)]
	 * </p>
	 *
	 * @param eventType            The specific NodeDiscoveryEvent that occurred. Required for logging.
	 * @param remoteNodeUuid       The UUID string of the remote node involved in the event.
	 * @param remoteNodeEndpointId The endpoint ID provided by Nearby Connections for the remote node.
	 * @param remoteNodeName       The human-readable name of the remote node. Can be null if not available.
	 * @param additionalInfo       Optional string for any extra, event-specific details. Can be an empty string if not needed.
	 */
	public static synchronized void logNodeEvent(
			NodeDiscoveryEvent eventType, String remoteNodeUuid,
			String remoteNodeEndpointId, String remoteNodeName, String additionalInfo) {

		// Log an error to Logcat and return if the DataLog is not properly initialized
		if (writer == null || localNodeUuid == null || eventType == null) {
			Log.w(TAG, "DataLog not initialized. Skipping logNodeEvent for type: "
					+ (eventType != null ? eventType.name() : "NULL_EVENT_TYPE"));
			return;
		}

		long timestamp = System.currentTimeMillis(); // Automatically generated timestamp

		// Ensure all string arguments are non-null to prevent NullPointerExceptions in String.format
		String safeRemoteNodeUuid = (remoteNodeUuid != null) ? remoteNodeUuid : "";
		String safeRemoteNodeEndpointId = (remoteNodeEndpointId != null) ? remoteNodeEndpointId : "";
		String safeRemoteNodeName = (remoteNodeName != null) ? remoteNodeName : "";
		String safeAdditionalInfo = (additionalInfo != null) ? additionalInfo : "";

		// Construct the log line according to the specified format
		String logLine = String.format(
				Locale.US, // Use US locale for consistent number formatting
				"%d NODE_DISCOVERY %s %s %s %s %s %s",
				timestamp,
				localNodeUuid,
				eventType.name(), // Convert enum to its String name
				safeRemoteNodeUuid,
				safeRemoteNodeEndpointId,
				safeRemoteNodeName,
				safeAdditionalInfo
		);

		writeLogToFile(logLine);
	}

	/**
	 * Internal helper method to perform the actual writing of a log entry to the file.
	 * This method ensures thread-safety for file write operations.
	 *
	 * @param logEntry The formatted string representing the log entry to write.
	 */
	private static void writeLogToFile(String logEntry) {
		if (writer != null) {
			try {
				writer.append(logEntry).append("\n"); // Append the log line followed by a newline character
				writer.flush(); // Force the buffered data to be written to disk immediately
			} catch (IOException e) {
				// Log any writing errors to Android's Logcat, as the file logging itself has failed
				Log.w(TAG, "Error writing log entry to file: " + e.getMessage(), e);
			}
		}
	}

	/**
	 * Closes the underlying FileWriter. This method should be called when the application
	 * or the main service is shutting down to release file resources and ensure all
	 * pending logs are written.
	 */
	public static synchronized void close() {
		if (writer != null) {
			try {
				writer.close();
				writer = null; // Reset writer to null after closing
				appContext = null; // Free context reference to prevent potential memory leaks
				Log.i(TAG, "DataLog file closed.");
			} catch (IOException e) {
				Log.e(TAG, "Error closing DataLog file: " + e.getMessage(), e);
			}
		}
	}

	/**
	 * Enum defining specific events related to node discovery and connection management.
	 * Each event type corresponds to a distinct state change or action in the Nearby Connections flow.
	 */
	public enum NodeDiscoveryEvent {
		FOUND,          // A remote node has been discovered (onEndpointFound callback).
		LOST,           // A previously discovered node is no longer detectable (onEndpointLost callback).
		INIT_BY_HOST,   // Connection attempt initiated by this node (requestConnection).
		INIT_BY_REMOTE, // Connection attempt initiated by the remote node (onConnectionInitiated callback).
		ACCEPT,         // Connection request from a remote node has been accepted by this node.
		REJECT,         // Connection request from a remote node has been rejected by this node.
		DISCONNECT,     // An existing connection with a remote node has been disconnected (onDisconnected callback).
		FAILED,         // Connection attempt failed
	}
}
