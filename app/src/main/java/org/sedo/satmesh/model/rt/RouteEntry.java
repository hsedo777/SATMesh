package org.sedo.satmesh.model.rt; // Package added as requested

import androidx.annotation.NonNull;
import androidx.room.ColumnInfo;
import androidx.room.Embedded;
import androidx.room.Entity;
import androidx.room.Index;
import androidx.room.PrimaryKey;

import java.util.Objects;

/**
 * Represents a specific route entry discovered in the decentralized mesh network.
 * This class encapsulates the details of a path from the current node to a destination node,
 * as learned through a particular route discovery request.
 * It is designed to be stored locally in a node's RoutingTable.
 */
@Entity(tableName = "route_entry",
		indices = {
				// Unique index on discovery_uuid to ensure only one route entry per discovery process
				@Index(value = {"discovery_uuid"}, unique = true),
				// Non-unique indices on `*_id` for efficient lookup of nodes
				@Index(value = {"destination_node_local_id"}),
				@Index("next_hop_local_id"), @Index("previous_hop_local_id")
		})
public class RouteEntry {

	// Primary key for local database storage, typically auto-generated by Room.
	@PrimaryKey(autoGenerate = true)
	private Long id;

	// The UUID of the RouteRequestMessage that is used for discovering this specific route instance.
	@ColumnInfo(name = "discovery_uuid")
	private String discoveryUuid;

	// The local identifier (Long) of the final destination node for this route.
	@ColumnInfo(name = "destination_node_local_id")
	private Long destinationNodeLocalId;

	// The local identifier (Long) of the immediate next hop node towards the destination.
	// Traffic will be forwarded to this node to follow this route.
	@ColumnInfo(name = "next_hop_local_id")
	private Long nextHopLocalId;

	// The local identifier (Long) of the previous hop node that relayed the
	// RouteResponseMessage (or RouteRequestMessage during discovery) to the current node.
	// Essential for backtracking the response and understanding path formation.
	@ColumnInfo(name = "previous_hop_local_id")
	private Long previousHopLocalId;

	// The total number of hops (intermediate nodes + destination) from the current node
	// to the destination node via this specific path.
	@ColumnInfo(name = "hop_count")
	private Integer hopCount;

	/**
	 * Default constructor. Room requires a public no-argument constructor.
	 */
	public RouteEntry() {
	}

	// --- Getters ---

	public Long getId() {
		return id;
	}

	public void setId(Long id) {
		this.id = id;
	}

	public String getDiscoveryUuid() {
		return discoveryUuid;
	}

	public void setDiscoveryUuid(String discoveryUuid) {
		this.discoveryUuid = discoveryUuid;
	}

	public Long getDestinationNodeLocalId() {
		return destinationNodeLocalId;
	}

	public void setDestinationNodeLocalId(Long destinationNodeLocalId) {
		this.destinationNodeLocalId = destinationNodeLocalId;
	}

	// --- Setters ---

	public Long getNextHopLocalId() {
		return nextHopLocalId;
	}

	public void setNextHopLocalId(Long nextHopLocalId) {
		this.nextHopLocalId = nextHopLocalId;
	}

	public Long getPreviousHopLocalId() {
		return previousHopLocalId;
	}

	public void setPreviousHopLocalId(Long previousHopLocalId) {
		this.previousHopLocalId = previousHopLocalId;
	}

	public Integer getHopCount() {
		return hopCount;
	}

	public void setHopCount(Integer hopCount) {
		this.hopCount = hopCount;
	}

	/**
	 * Checks if the route path is "opened" or fully established,
	 * meaning the next hop is defined. Note that the next hop is defined at time of handling
	 * a positive route request response. And the previous hop is always known at the route
	 * entry creation. Its value is {@code null} if the creator is the initiator of the route
	 * request, and a non-null value else.
	 * This indicates that the discovery process for this segment of the route is complete.
	 *
	 * @return true if nextHopLocalId is not null, false otherwise.
	 */
	public boolean isOpened() {
		return nextHopLocalId != null;
	}

	@Override
	public boolean equals(Object o) {
		if (this == o) return true;
		if (o == null || getClass() != o.getClass()) return false;
		RouteEntry that = (RouteEntry) o;
		return Objects.equals(discoveryUuid, that.discoveryUuid) && Objects.equals(destinationNodeLocalId, that.destinationNodeLocalId) && Objects.equals(nextHopLocalId, that.nextHopLocalId) && Objects.equals(previousHopLocalId, that.previousHopLocalId) && Objects.equals(hopCount, that.hopCount);
	}

	@Override
	public int hashCode() {
		return Objects.hash(discoveryUuid, destinationNodeLocalId, nextHopLocalId, previousHopLocalId, hopCount);
	}

	@NonNull
	@Override
	public String toString() {
		return "RouteEntry{" +
				"id=" + id +
				", discoveryUuid='" + discoveryUuid + '\'' +
				", destinationNodeLocalId=" + destinationNodeLocalId +
				", nextHopLocalId=" + nextHopLocalId +
				", previousHopLocalId=" + previousHopLocalId +
				", hopCount=" + hopCount +
				'}';
	}

	/**
	 * Wrapper for {@link RouteEntry} and a date of usage (often the date of last usage).
	 *
	 * @author hovozounkou
	 */
	public static class RouteWithUsageTimestamp {
		@Embedded
		public RouteEntry routeEntry;
		public long last_used_timestamp;

		public RouteWithUsageTimestamp(@NonNull RouteEntry routeEntry, long last_used_timestamp) {
			this.routeEntry = routeEntry;
			this.last_used_timestamp = last_used_timestamp;
		}

		// Getter methods
		public RouteEntry getRouteEntry() {
			return routeEntry;
		}

		public long getLastUsedTimestamp() {
			return last_used_timestamp;
		}

		@Override
		public boolean equals(Object o) {
			if (this == o) return true;
			if (o == null || getClass() != o.getClass()) return false;
			RouteWithUsageTimestamp that = (RouteWithUsageTimestamp) o;
			return last_used_timestamp == that.last_used_timestamp &&
					Objects.equals(routeEntry, that.routeEntry);
		}

		@Override
		public int hashCode() {
			return Objects.hash(routeEntry, last_used_timestamp);
		}

		@NonNull
		@Override
		public String toString() {
			return "RouteWithUsageTimestamp{" +
					"routeEntry=" + routeEntry +
					", last_used_timestamp=" + last_used_timestamp +
					'}';
		}
	}
}
