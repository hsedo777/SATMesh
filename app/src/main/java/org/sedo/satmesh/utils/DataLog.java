package org.sedo.satmesh.utils;

import android.content.Context;
import android.util.Log;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Locale;
import java.util.Map;

/**
 * Manages the logging of performance and behavior data for the SATMesh application
 * into a dedicated file. This allows for subsequent automated analysis.
 * It uses a structured format for each log entry to facilitate parsing.
 * <p>
 * This class ensures thread-safe operations for logging.
 * </p>
 *
 * @author hsedo777
 */
public class DataLog {

	// Route discovery map' keys
	public static final String PARAM_INTERACTING_NODE_UUID = "interactingNodeUuid";
	public static final String PARAM_STATUS_OR_REASON = "statusOrReason";
	public static final String PARAM_HOPS = "hops";
	public static final String PARAM_ADDITIONAL_INFO = "additionalInfo";
	public static final String PARAM_SOURCE_NODE_UUID = "sourceNodeUuid";
	public static final String PARAM_DEST_NODE_UUID = "destNodeUuid";
	private static final String TAG = "DataLog";
	// Log File Configuration
	private static final String LOG_FILE_DIR_NAME = "satmesh_logs";
	private static final String LOG_FILE_BASE_NAME = "data_log_";
	private static final String LOG_FILE_EXTENSION = ".txt";
	private static FileWriter writer;
	private static Context appContext; // Application context for file operations
	private static String localNodeUuid; // UUID of the local node, included in logs for context

	private DataLog() {
	}

	/**
	 * Initializes the DataLog manager. This method must be called once at the application's startup.
	 * It sets up the logging directory and creates/opens the log file for appending.
	 * All logging methods will be non-operational until this initialization is successful.
	 *
	 * @param context  The application context.
	 * @param nodeUuid The unique UUID string of the local node. This UUID will be included
	 *                 in every log entry generated by this instance for identification.
	 */
	public static synchronized void init(Context context, String nodeUuid) {
		if (writer == null) { // Ensure initialization happens only once
			appContext = context.getApplicationContext();
			localNodeUuid = nodeUuid;
			try {
				/*
				 * Using getExternalFilesDir ensures application-specific storage,
				 * which does not require WRITE_EXTERNAL_STORAGE permission on modern Android versions.
				 * Files are stored in: Android/data/(my.package)/files/satmesh_logs
				 */
				File logDir = new File(appContext.getExternalFilesDir(null), LOG_FILE_DIR_NAME);
				if (!logDir.exists()) {
					// Create the directory if it does not exist
					if (!logDir.mkdirs()) {
						Log.w(TAG, "Unable to create the log directory: " + logDir.getAbsolutePath());
						return;
					}
				}

				// Append current date to the log file name for easier management and rotation
				String dateStr = new SimpleDateFormat("yyyyMMdd", Locale.US).format(new Date());
				File currentLogFile = new File(logDir, LOG_FILE_BASE_NAME + dateStr + LOG_FILE_EXTENSION);

				// Initialize FileWriter in append mode (true)
				writer = new FileWriter(currentLogFile, true);
				Log.i(TAG, "DataLog initialized. File path: " + currentLogFile.getAbsolutePath());
			} catch (IOException e) {
				Log.e(TAG, "Error initializing DataLog file: " + e.getMessage(), e);
				writer = null; // Set writer to null to indicate initialization failure
			}
		}
	}

	/**
	 * Logs an event related to node discovery or connection status.
	 * This method automatically adds a timestamp and the local node's UUID.
	 * <p>
	 * The log entry format is:
	 * [TIMESTAMP_MS] NODE_DISCOVERY [LOCAL_NODE_UUID] [EVENT_TYPE] [REMOTE_NODE_UUID] [REMOTE_NODE_ENDPOINT_ID] [REMOTE_NODE_NAME] [ADDITIONAL_INFO (optional)]
	 * </p>
	 *
	 * @param eventType            The specific NodeDiscoveryEvent that occurred. Required for logging.
	 * @param remoteNodeUuid       The UUID string of the remote node involved in the event.
	 * @param remoteNodeEndpointId The endpoint ID provided by Nearby Connections for the remote node.
	 * @param additionalInfo       Optional string for any extra, event-specific details. Can be an empty string if not needed.
	 */
	public static synchronized void logNodeEvent(
			NodeDiscoveryEvent eventType, String remoteNodeUuid,
			String remoteNodeEndpointId, String additionalInfo) {

		// Log an error to Logcat and return if the DataLog is not properly initialized
		if (writer == null || localNodeUuid == null || eventType == null) {
			Log.w(TAG, "DataLog not initialized. Skipping logNodeEvent for type: "
					+ (eventType != null ? eventType.name() : "NULL_EVENT_TYPE"));
			return;
		}

		long timestamp = System.currentTimeMillis(); // Automatically generated timestamp

		// Ensure all string arguments are non-null to prevent NullPointerExceptions in String.format
		String safeRemoteNodeUuid = (remoteNodeUuid != null) ? remoteNodeUuid : "";
		String safeRemoteNodeEndpointId = (remoteNodeEndpointId != null) ? remoteNodeEndpointId : "";
		String safeAdditionalInfo = (additionalInfo != null) ? additionalInfo : "";

		// Construct the log line according to the specified format
		String logLine = String.format(
				Locale.US, // Use US locale for consistent number formatting
				"%d NODE_DISCOVERY %s %s %s %s %s %s",
				timestamp,
				localNodeUuid,
				eventType.name(), // Convert enum to its String name
				safeRemoteNodeUuid,
				safeRemoteNodeEndpointId,
				"",
				safeAdditionalInfo
		);

		writeLogToFile(logLine);
	}

	/**
	 * Logs an event related to the routing process.
	 * This method automatically adds a timestamp and the local node's UUID.
	 * <p>
	 * The log entry format is:
	 * [TIMESTAMP_MS] ROUTING [LOCAL_NODE_UUID] [EVENT_TYPE] [REQUEST_UUID] [SOURCE_NODE_UUID] [DEST_NODE_UUID] [INTERACTING_NODE_UUID] [STATUS_OR_REASON] [HOPS] [ADDITIONAL_INFO]
	 * All optional fields will be logged as an empty string "" if not provided in the 'params' map or are not applicable.
	 * </p>
	 *
	 * @param eventType   The specific {@link RouteDiscoveryEvent} that occurred. Required.
	 * @param requestUuid The UUID of the route request. Use null or empty string if not applicable.
	 * @param params      A map containing additional key-value pairs for specific event details.
	 *                    Use predefined static keys from LogToFileManager (e.g., PARAM_SOURCE_NODE_UUID).
	 *                    <br>Common parameters:
	 *                    - {@link #PARAM_INTERACTING_NODE_UUID} (String): UUID of the neighbor involved.
	 *                    - {@link #PARAM_STATUS_OR_REASON} (String): Status or reason for the event (e.g., "ROUTE_FOUND", "NO_ROUTE_FOUND").
	 *                    - {@link #PARAM_HOPS} (String): Number of hops (e.g., "1", "3").
	 *                    - {@link #PARAM_ADDITIONAL_INFO} (String): Any extra, event-specific details.
	 *                    - {@link #PARAM_SOURCE_NODE_UUID} (String): UUID of the original source node (ONLY for initiator node).
	 *                    - {@link #PARAM_DEST_NODE_UUID} (String): UUID of the destination node for the request or route entry.
	 */
	public static synchronized void logRouteEvent(
			RouteDiscoveryEvent eventType, String requestUuid, Map<String, String> params) {

		// Log an error to Logcat and return if DataLog is not properly initialized or eventType is null
		if (writer == null || localNodeUuid == null || eventType == null) {
			Log.w(TAG, "DataLog not initialized or eventType is null. Skipping logRouteEvent for type: "
					+ (eventType != null ? eventType.name() : "NULL_EVENT_TYPE"));
			return;
		}

		long timestamp = System.currentTimeMillis(); // Automatically generated timestamp

		String safeRequestUuid = requestUuid != null ? requestUuid : "";
		String sourceNodeUuid = getParam(params, PARAM_SOURCE_NODE_UUID);
		String destNodeUuid = getParam(params, PARAM_DEST_NODE_UUID);
		String interactingNodeUuid = getParam(params, PARAM_INTERACTING_NODE_UUID);
		String statusOrReason = getParam(params, PARAM_STATUS_OR_REASON);
		String hops = getParam(params, PARAM_HOPS);
		String additionalInfo = getParam(params, PARAM_ADDITIONAL_INFO);

		// Construct the log line according to the specified format
		String logLine = String.format(
				Locale.US, // Use US locale for consistent number formatting
				"%d ROUTING %s %s %s %s %s %s %s %s \"%s\"",
				timestamp,
				localNodeUuid,
				eventType.name(), // Convert enum to its String name
				safeRequestUuid,
				sourceNodeUuid,
				destNodeUuid,
				interactingNodeUuid,
				statusOrReason,
				hops,
				additionalInfo
		);

		writeLogToFile(logLine);
	}

	private static synchronized String getParam(Map<String, String> params, String key) {
		return (params != null && params.containsKey(key)) ? params.get(key) : "";
	}

	/**
	 * Internal helper method to perform the actual writing of a log entry to the file.
	 * This method ensures thread-safety for file write operations.
	 *
	 * @param logEntry The formatted string representing the log entry to write.
	 */
	private static synchronized void writeLogToFile(String logEntry) {
		if (writer != null) {
			try {
				writer.append(logEntry).append("\n"); // Append the log line followed by a newline character
				writer.flush(); // Force the buffered data to be written to disk immediately
			} catch (IOException e) {
				// Log any writing errors to Android's Logcat, as the file logging itself has failed
				Log.w(TAG, "Error writing log entry to file: " + e.getMessage(), e);
			}
		}
	}

	/**
	 * Logs a transmission event (send or receive) of a payload over Nearby Connections.
	 * Format:
	 * [TIMESTAMP_MS] TRANSMISSION [EVENT_TYPE] [ENDPOINT_ID] [PAYLOAD_ID] [SIZE_BYTES] [STATUS]
	 *
	 * @param eventType  Whether it was a SEND or RECEIVE event.
	 * @param endpointId The endpoint ID of the other party.
	 * @param payloadId  The ID of the payload if known, or 0L if not applicable (e.g. on failure).
	 * @param sizeBytes  The size of the payload in bytes.
	 * @param status     SUCCESS or FAILURE.
	 */
	public static synchronized void logTransmissionEvent(
			TransmissionEventType eventType, String endpointId, long payloadId, int sizeBytes, TransmissionStatus status) {

		if (writer == null || eventType == null || status == null) {
			Log.w(TAG, "DataLog not initialized or invalid params. Skipping logTransmissionEvent: event=" + eventType + ", status=" + status);
			return;
		}

		long timestamp = System.currentTimeMillis();
		String safeEndpointId = endpointId != null ? endpointId : "";
		String payloadIdStr = (payloadId != 0) ? String.valueOf(payloadId) : ""; // omit if unknown

		String logLine = String.format(
				Locale.US,
				"%d TRANSMISSION %s %s %s %d %s",
				timestamp,
				eventType.name(),
				safeEndpointId,
				payloadIdStr,
				sizeBytes,
				status.name()
		);

		writeLogToFile(logLine);
	}


	/**
	 * Closes the underlying FileWriter. This method should be called when the application
	 * or the main service is shutting down to release file resources and ensure all
	 * pending logs are written.
	 */
	public static synchronized void close() {
		if (writer != null) {
			try {
				writer.close();
				writer = null; // Reset writer to null after closing
				appContext = null; // Free context reference to prevent potential memory leaks
				Log.i(TAG, "DataLog file closed.");
			} catch (IOException e) {
				Log.e(TAG, "Error closing DataLog file: " + e.getMessage(), e);
			}
		}
	}

	/**
	 * Enum defining specific events related to node discovery and connection management.
	 * Each event type corresponds to a distinct state change or action in the Nearby Connections flow.
	 */
	public enum NodeDiscoveryEvent {
		FOUND,          // A remote node has been discovered (onEndpointFound callback).
		LOST,           // A previously discovered node is no longer detectable (onEndpointLost callback).
		INIT_BY_HOST,   // Connection attempt initiated by this node (requestConnection).
		INIT_BY_REMOTE, // Connection attempt initiated by the remote node (onConnectionInitiated callback).
		ACCEPT,         // Connection request from a remote node has been accepted by this node.
		REJECT,         // Connection request from a remote node has been rejected by this node.
		DISCONNECT,     // An existing connection with a remote node has been disconnected (onDisconnected callback).
		FAILED,         // Connection attempt failed (e.g., onConnectionResult with a FAILED status).
	}

	/**
	 * Represents the various types of events that can occur during the route discovery
	 * process within the SATMesh routing module.
	 * These events are intended to be used for detailed logging and analysis
	 * of the routing algorithm's behavior and performance.
	 *
	 * @author hsedo777
	 */
	public enum RouteDiscoveryEvent {
		/**
		 * Indicates that the local node has initiated a new route request
		 * towards a specific destination. This is the starting point of a route search.
		 */
		ROUTE_REQ_INIT,

		/**
		 * Indicates that the local node has received a route request message
		 * and has relayed it to one or more of its neighbors. This covers
		 * both relaying requests received from other nodes and sending
		 * initial requests to immediate neighbors.
		 */
		ROUTE_REQ_RELAYED,

		/**
		 * Indicates that the local node has generated and sent a route response message
		 * (either positive or negative) back to a previous hop.
		 */
		ROUTE_RESP_SENT,

		/**
		 * Indicates that the local node has received a route response message
		 * from one of its immediate neighbors.
		 */
		ROUTE_RESP_RCVD,

		/**
		 * Indicates that the local node has received a route response message
		 * from one of its immediate neighbors but the response is late and won't
		 * be relayed to previous.
		 */
		ROUTE_RESP_LATE,

		/**
		 * Indicates that a complete and valid route has been successfully established
		 * for a given request UUID. This event is logged by the original source node
		 * once it receives the final route confirmation.
		 */
		ROUTE_FOUND,

		/**
		 * Indicates that the attempt to find a route for a specific request UUID has failed.
		 * This event is logged by the original source node after exhausting all discovery branches.
		 */
		ROUTE_FAILED,

		/**
		 * Indicates that a new route entry has been successfully added to the
		 * local node's routing table ({@code RouteEntry}).
		 */
		ROUTE_ENTRY_ADD,

		/**
		 * Indicates that a route entry has been removed from the local node's
		 * routing table ({@code RouteEntry}), typically due to invalidation,
		 * expiration, or replacement by a better route.
		 */
		ROUTE_ENTRY_DEL,

		/**
		 * Indicates that a {@code BroadcastStatusEntry} has been deleted
		 * for a specific route request and a particular neighbor. This signifies
		 * the conclusion of a branch in the broadcast discovery.
		 */
		BROADCAST_STATUS_DEL,

		/**
		 * Indicates that a {@code RequestEntry} has been deleted from the local node's
		 * request table ({@code RequestTable}). This happens when a route request
		 * has been fully resolved (either found or definitively failed).
		 */
		REQUEST_ENTRY_DEL
	}

	public enum TransmissionEventType {
		SEND, RECEIVE
	}

	public enum TransmissionStatus {
		SUCCESS, FAILURE
	}

}
