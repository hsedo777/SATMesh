package org.sedo.satmesh.model;


import static androidx.room.ForeignKey.CASCADE;

import androidx.room.ColumnInfo;
import androidx.room.Entity;
import androidx.room.ForeignKey;
import androidx.room.Index;
import androidx.room.PrimaryKey;

import java.util.Arrays;
import java.util.List;
import java.util.Objects;

/**
 * Represents a message sent or received in the application.
 * Messages can be of various types (text, image, etc.) and have different statuses
 * indicating their delivery and read state.
 */
@Entity(tableName = "message",
		foreignKeys = {
				@ForeignKey(entity = Node.class,
						parentColumns = "id", // Foreign key from Node's primary key (id)
						childColumns = "senderNodeId", // Column in Message for the sender's Node ID
						onDelete = CASCADE), // If a sender node is deleted, delete their messages
				@ForeignKey(entity = Node.class,
						parentColumns = "id", // Foreign key from Node's primary key (id)
						childColumns = "recipientNodeId", // Column in Message for the recipient's Node ID
						onDelete = CASCADE) // If a recipient node is deleted, delete associated messages
		},
		indices = {@Index(value = "payloadId", unique = true), @Index(value = "senderNodeId"), @Index("recipientNodeId")})
public class Message {

	//For messages statuses, we opt to use integer constants instead of enum constants
	/**
	 * Message status code when the message is pending (waiting to be sent/routed).
	 */
	public static final int MESSAGE_STATUS_PENDING = 1;
	/**
	 * Message status code when the message has been successfully delivered to the recipient.
	 */
	public static final int MESSAGE_STATUS_DELIVERED = 2;
	/**
	 * Message status code when the message sending fails (e.g., no route found, timeout).
	 */
	public static final int MESSAGE_STATUS_FAILED = 3;
	/**
	 * Message status code when the recipient has read the message.
	 */
	public static final int MESSAGE_STATUS_READ = 4;
	/**
	 * Message status code when the message is actively being routed through the mesh network
	 * but no delivery confirmation has been received yet.
	 */
	public static final int MESSAGE_STATUS_ROUTING = 5;
	/**
	 * Used to mark message when it was sent in context where there is no active secure
	 * session between the implied nodes.
	 */
	public static final int MESSAGE_STATUS_PENDING_KEY_EXCHANGE = 6;
	/**
	 * Message status code when the message has been successfully
	 * sent (when receiver is a neighbor) and is awaiting delivery confirmation.
	 */
	public static final int MESSAGE_STATUS_SENT = 7;

	/**
	 * Code for a text message.
	 */
	public static final int MESSAGE_TYPE_TEXT = 0;

	//For message type, we opt to integer constants instead of enum constants
	/**
	 * Code for an image message. (Note: Current implementation might not support this yet)
	 */
	public static final int MESSAGE_TYPE_IMAGE = 1;
	/**
	 * Code for an audio message/voice note. (Note: Current implementation might not support this yet)
	 */
	public static final int MESSAGE_TYPE_AUDIO = 2;
	/**
	 * Code for a file message. (Note: Current implementation might not support this yet)
	 */
	public static final int MESSAGE_TYPE_FILE = 3;
	// List of messages statuses
	private static final List<Integer> MESSAGE_STATUSES = Arrays.asList(
			MESSAGE_STATUS_DELIVERED,
			MESSAGE_STATUS_PENDING,
			MESSAGE_STATUS_ROUTING,
			MESSAGE_STATUS_READ,
			MESSAGE_STATUS_FAILED,
			MESSAGE_STATUS_PENDING_KEY_EXCHANGE,
			MESSAGE_STATUS_SENT);
	// List of message types
	private static final List<Integer> MESSAGE_TYPES = Arrays.asList(
			MESSAGE_TYPE_TEXT,
			MESSAGE_TYPE_IMAGE,
			MESSAGE_TYPE_AUDIO,
			MESSAGE_TYPE_FILE);

	@PrimaryKey(autoGenerate = true)
	private Long id;

	/**
	 * A unique identifier for the message's payload, typically generated by the sender.
	 * Used for tracking delivery and read receipts across the network.
	 */
	private Long payloadId;

	/**
	 * The content of the message. For text messages, this is the actual text.
	 * For other types (image, audio, file), this will be a local URI or path to the content.
	 */
	private String content;

	/**
	 * The timestamp when the message was sent, in milliseconds since the epoch.
	 */
	private long timestamp;

	/**
	 * The current status of the message (e.g., PENDING, DELIVERED, FAILED, READ, ROUTING).
	 * Uses MESSAGE_STATUS_* constants.
	 */
	private int status;

	/**
	 * The type of the message (e.g., TEXT, IMAGE, AUDIO, FILE).
	 * Uses MESSAGE_TYPE_* constants.
	 */
	private int type;

	/**
	 * The database ID of the sender Node.
	 * This acts as a foreign key to the 'node' table's 'id' column.
	 */
	@ColumnInfo(name = "senderNodeId")
	private Long senderNodeId;

	/**
	 * The database ID of the recipient Node.
	 * This acts as a foreign key to the 'node' table's 'id' column.
	 */
	@ColumnInfo(name = "recipientNodeId")
	private Long recipientNodeId;

	/**
	 * The last time the message has been transmitted but without
	 * transmission result even if success or failure. It is also
	 * used to retain the last time the message was sent but without
	 * any ack from the recipient.
	 */
	@ColumnInfo(name = "lastAttempt")
	private Long lastSendingAttempt;

	/**
	 * Test if the input integer value is a valid status code
	 *
	 * @param status the code to test
	 * @return {@code true} is and only if the input value match any of constants started by {@code MESSAGE_STATUS}.
	 */
	public static boolean isValidStatusCode(int status) {
		return MESSAGE_STATUSES.contains(status);
	}

	/**
	 * Test if the input integer value is a valid message type
	 *
	 * @param type the code to test
	 * @return {@code true} is and only if the input value match any of constants started by {@code MESSAGE_TYPE}.
	 */
	public static boolean isValidMessageTpe(int type) {
		return MESSAGE_TYPES.contains(type);
	}

	public Long getId() {
		return id;
	}

	public void setId(Long id) {
		this.id = id;
	}

	public Long getPayloadId() {
		return payloadId;
	}

	public void setPayloadId(Long payloadId) {
		if ((payloadId != null && payloadId == 0L)
				|| (this.payloadId != null && this.payloadId != 0L) //Prevent payload ID modification
		) {
			return;
		}
		this.payloadId = payloadId;
	}

	public String getContent() {
		return content;
	}

	public void setContent(String content) {
		this.content = content;
	}

	public long getTimestamp() {
		return timestamp;
	}

	public void setTimestamp(long timestamp) {
		this.timestamp = timestamp;
	}

	public int getStatus() {
		return status;
	}

	public void setStatus(int status) {
		if (!isValidStatusCode(status)) return;
		this.status = status;
	}

	public int getType() {
		return type;
	}

	public void setType(int type) {
		if (!isValidMessageTpe(type)) return;
		this.type = type;
	}

	public Long getSenderNodeId() {
		return senderNodeId;
	}

	public void setSenderNodeId(Long senderNodeId) {
		this.senderNodeId = senderNodeId;
	}

	public Long getRecipientNodeId() {
		return recipientNodeId;
	}

	public void setRecipientNodeId(Long recipientNodeId) {
		this.recipientNodeId = recipientNodeId;
	}

	public boolean isDelivered() {
		return status == MESSAGE_STATUS_DELIVERED;
	}

	public boolean isRead() {
		return status == MESSAGE_STATUS_READ;
	}

	public Long getLastSendingAttempt() {
		return lastSendingAttempt;
	}

	public void setLastSendingAttempt(Long lastSendingAttempt) {
		this.lastSendingAttempt = lastSendingAttempt;
	}

	@Override
	public boolean equals(Object o) {
		if (this == o) return true;
		if (o == null || getClass() != o.getClass()) return false;
		Message message = (Message) o;
		return timestamp == message.timestamp && status == message.status && type == message.type && Objects.equals(payloadId, message.payloadId) && Objects.equals(content, message.content) && Objects.equals(senderNodeId, message.senderNodeId) && Objects.equals(recipientNodeId, message.recipientNodeId);
	}

	@Override
	public int hashCode() {
		return Objects.hash(payloadId, content, timestamp, status, type, senderNodeId, recipientNodeId);
	}
}
