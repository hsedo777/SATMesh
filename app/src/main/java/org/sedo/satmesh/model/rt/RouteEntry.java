package org.sedo.satmesh.model.rt;

import androidx.annotation.NonNull;
import androidx.room.ColumnInfo;
import androidx.room.Embedded;
import androidx.room.Entity;
import androidx.room.Index;
import androidx.room.PrimaryKey;

import java.util.Objects;

/**
 * Represents a specific route entry discovered in the decentralized mesh network.
 * This class encapsulates the details of a path from the current node to a destination node,
 * as learned through a particular route discovery request.
 * It is designed to be stored locally in a node's RoutingTable.
 */
@Entity(tableName = "route_entry",
		indices = {
				// Unique index on discovery_uuid to ensure only one route entry per discovery process
				@Index(value = {"discovery_uuid"}, unique = true),
				// Non-unique indices on `*_id` for efficient lookup of nodes
				@Index(value = {"destination_node_local_id"}),
				@Index("next_hop_local_id"), @Index("previous_hop_local_id")
		})
public class RouteEntry {

	// Primary key for local database storage, typically auto-generated by Room.
	@PrimaryKey(autoGenerate = true)
	private Long id;

	// The UUID of the RouteRequestMessage that is used for discovering this specific route instance.
	@ColumnInfo(name = "discovery_uuid")
	private String discoveryUuid;

	// The local identifier (Long) of the final destination node for this route.
	@ColumnInfo(name = "destination_node_local_id")
	private Long destinationNodeLocalId;

	// The local identifier (Long) of the immediate next hop node towards the destination.
	// Traffic will be forwarded to this node to follow this route.
	@ColumnInfo(name = "next_hop_local_id")
	private Long nextHopLocalId;

	// The local identifier (Long) of the previous hop node that relayed the
	// RouteResponseMessage (or RouteRequestMessage during discovery) to the current node.
	// Essential for backtracking the response and understanding path formation.
	@ColumnInfo(name = "previous_hop_local_id")
	private Long previousHopLocalId;

	// The total number of hops (intermediate nodes + destination) from the current node
	// to the destination node via this specific path.
	@ColumnInfo(name = "hop_count")
	private Integer hopCount;

	/*
	 * The date of last use of this route.
	 * This timestamp is critical for implementing the 12-hour inactivity expiration logic.
	 */
	@ColumnInfo(name = "last_use_timestamp")
	private Long lastUseTimestamp;

	/**
	 * Default constructor. Room requires a public no-argument constructor.
	 */
	public RouteEntry() {
	}

	public Long getId() {
		return id;
	}

	public void setId(Long id) {
		this.id = id;
	}

	public String getDiscoveryUuid() {
		return discoveryUuid;
	}

	public void setDiscoveryUuid(String discoveryUuid) {
		this.discoveryUuid = discoveryUuid;
	}

	public Long getDestinationNodeLocalId() {
		return destinationNodeLocalId;
	}

	public void setDestinationNodeLocalId(Long destinationNodeLocalId) {
		this.destinationNodeLocalId = destinationNodeLocalId;
	}

	public Long getNextHopLocalId() {
		return nextHopLocalId;
	}

	public void setNextHopLocalId(Long nextHopLocalId) {
		this.nextHopLocalId = nextHopLocalId;
	}

	public Long getPreviousHopLocalId() {
		return previousHopLocalId;
	}

	public void setPreviousHopLocalId(Long previousHopLocalId) {
		this.previousHopLocalId = previousHopLocalId;
	}

	public Integer getHopCount() {
		return hopCount;
	}

	public void setHopCount(Integer hopCount) {
		this.hopCount = hopCount;
	}

	public Long getLastUseTimestamp() {
		return lastUseTimestamp;
	}

	public void setLastUseTimestamp(Long lastUseTimestamp) {
		this.lastUseTimestamp = lastUseTimestamp;
	}

	@Override
	public boolean equals(Object o) {
		if (this == o) return true;
		if (o == null || getClass() != o.getClass()) return false;
		RouteEntry that = (RouteEntry) o;
		return Objects.equals(discoveryUuid, that.discoveryUuid)
				&& Objects.equals(destinationNodeLocalId, that.destinationNodeLocalId)
				&& Objects.equals(nextHopLocalId, that.nextHopLocalId)
				&& Objects.equals(previousHopLocalId, that.previousHopLocalId)
				&& Objects.equals(hopCount, that.hopCount)
				&& Objects.equals(lastUseTimestamp, that.lastUseTimestamp);
	}

	@Override
	public int hashCode() {
		return Objects.hash(discoveryUuid, destinationNodeLocalId, nextHopLocalId, previousHopLocalId, hopCount, lastUseTimestamp);
	}

	@NonNull
	@Override
	public String toString() {
		return "RouteEntry{" +
				"id=" + id +
				", discoveryUuid='" + discoveryUuid + '\'' +
				", destinationNodeLocalId=" + destinationNodeLocalId +
				", nextHopLocalId=" + nextHopLocalId +
				", previousHopLocalId=" + previousHopLocalId +
				", hopCount=" + hopCount +
				", lastUseTimestamp=" + lastUseTimestamp +
				'}';
	}

	/**
	 * Wrapper for {@link RouteEntry} and a date of usage (often the date of last usage).
	 *
	 * @author hsedo777
	 */
	public static class RouteWithUsage {
		@Embedded
		@NonNull
		public RouteEntry routeEntry;
		@Embedded(prefix = "usage_")
		public RouteUsage routeUsage;
		@Embedded(prefix = "backtracking_")
		public RouteUsageBacktracking backtracking;

		public RouteWithUsage(@NonNull RouteEntry routeEntry, RouteUsage routeUsage, RouteUsageBacktracking backtracking) {
			this.routeEntry = routeEntry;
			this.routeUsage = routeUsage;
			this.backtracking = backtracking;
		}

		public boolean isWithoutUsage() {
			return routeUsage == null && backtracking == null;
		}

		@Override
		public boolean equals(Object o) {
			if (o == null || getClass() != o.getClass()) return false;
			RouteWithUsage that = (RouteWithUsage) o;
			return Objects.equals(routeEntry, that.routeEntry) &&
					Objects.equals(routeUsage, that.routeUsage) &&
					Objects.equals(backtracking, that.backtracking);
		}

		@Override
		public int hashCode() {
			return Objects.hash(routeEntry, routeUsage, backtracking);
		}

		@NonNull
		@Override
		public String toString() {
			return "RouteWithUsage{" +
					"routeEntry=" + routeEntry +
					", routeUsage=" + routeUsage +
					", backtracking=" + backtracking +
					'}';
		}
	}
}
